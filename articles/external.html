<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interfacing with External C++ Code • rstan</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Interfacing with External C++ Code">
<meta property="og:description" content="rstan">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rstan</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.26.24</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Other Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="https://mc-stan.org/rstanarm">rstanarm</a>
    </li>
    <li>
      <a href="https://mc-stan.org/bayesplot" class="external-link">bayesplot</a>
    </li>
    <li>
      <a href="https://mc-stan.org/shinystan" class="external-link">shinystan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/loo" class="external-link">loo</a>
    </li>
    <li>
      <a href="https://mc-stan.org/projpred" class="external-link">projpred</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstantools">rstantools</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://mc-stan.org" class="external-link">Stan</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://twitter.com/mcmc_stan" class="external-link">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/stan-dev/rstan" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://discourse.mc-stan.org/" class="external-link">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Interfacing with External C++ Code</h1>
                        <h4 data-toc-skip class="author">Stan
Development Team</h4>
            
            <h4 data-toc-skip class="date">2023-09-08</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/stan-dev/rstan/blob/HEAD/vignettes/external.Rmd" class="external-link"><code>vignettes/external.Rmd</code></a></small>
      <div class="hidden name"><code>external.Rmd</code></div>

    </div>

    
    
<p>Starting with the 2.13 release, it is much easier to use external C++
code in a Stan program. This vignette briefly illustrates how to do
so.</p>
<p>Suppose that you have (part of) a Stan program that involves
Fibonacci numbers, such as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="dt">int</span> fib(<span class="dt">int</span> n);</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="dt">int</span> fib(<span class="dt">int</span> n) {</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>    <span class="cf">if</span> (n &lt;= <span class="dv">0</span>) <span class="kw">reject</span>(<span class="st">"n must be positive"</span>);</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>    <span class="cf">return</span> n &lt;= <span class="dv">2</span> ? <span class="dv">1</span> : fib(n - <span class="dv">1</span>) + fib(n - <span class="dv">2</span>);</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  }</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>}</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="kw">model</span> {} <span class="co">// use the fib() function somehow</span></span></code></pre></div>
<p>On the second line, we have <em>declared</em> the <code>fib</code>
function before it is <em>defined</em> in order to call it
recursively.</p>
<p>For functions that are not recursive, it is not necessary to declare
them before defining them but it may be advantageous. For example, I
often like to hide the definitions of complicated utility functions that
are just a distraction using the <code>#include "file"</code>
mechanism</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="dt">real</span> complicated(<span class="dt">real</span> a, <span class="dt">real</span> b, <span class="dt">real</span> c, <span class="dt">real</span> d, <span class="dt">real</span> e, <span class="dt">real</span> f, <span class="dt">real</span> g);</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#include "complicated.stan"</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>}</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="kw">model</span> {} <span class="co">// use the complicated() function somehow</span></span></code></pre></div>
<p>This Stan program would have to be parsed using the
<code>stanc_builder</code> function in the <strong>rstan</strong>
package rather than the default <code>stanc</code> function (which is
called by <code>sampling</code> and <code>stan</code> internally).</p>
<p>Returning to the Fibonacci example, it is not necessary to define the
<code>fib</code> function using the Stan language because Stan programs
with functions that are <em>declared</em> but not <em>defined</em> can
use the standard capabilities of the C++ toolchain to provide the
function definitions in C++. For example, this program produces a parser
error by default</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mc</span> <span class="op">&lt;-</span> </span>
<span><span class="st">'</span></span>
<span><span class="st">functions { int fib(int n); }</span></span>
<span><span class="st">model {} // use the fib() function somehow</span></span>
<span><span class="st">'</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="../reference/stan_model.html">stan_model</a></span><span class="op">(</span>model_code <span class="op">=</span> <span class="va">mc</span>, model_name <span class="op">=</span> <span class="st">"parser_error"</span><span class="op">)</span>, silent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>However, if we specify the <code>allow_undefined</code> and
<code>includes</code> arguments to the <code>stan_model</code> function,
and define a <code>fib</code> function in the named C++ header file,
then it will parse and compile</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/stan_model.html">stan_model</a></span><span class="op">(</span>model_code <span class="op">=</span> <span class="va">mc</span>, model_name <span class="op">=</span> <span class="st">"external"</span>, allow_undefined <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>           includes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">'\n#include "'</span>, </span>
<span>                             <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/getwd.html" class="external-link">getwd</a></span><span class="op">(</span><span class="op">)</span>, <span class="st">'fib.hpp'</span><span class="op">)</span>, <span class="st">'"\n'</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Specifying the <code>includes</code> argument is a bit awkward
because the C++ representation of a Stan program is written and compiled
in a temporary directory. Thus, the <code>includes</code> argument must
specify a <em>full</em> path to the fib.hpp file, which in this case is
in the working directory. Also, the path must be enclosed in
double-quotes, which is why single quotes are used in the separate
arguments to the <code>paste0</code> function so that double-quotes are
interpreted literally. Finally, the <code>includes</code> argument
should include newline characters (<code>"\n"</code>) at the start and
end. It is possible to specify multiple paths using additional newline
characters or include a “meta-header” file that contains
<code>#include</code> directives to other C++ header files.</p>
<p>The result of the <code>includes</code> argument is inserted into the
C++ file directly at the end of the lines (as opposed to CmdStan where
it is inserted directly <em>before</em> the following lines)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stan/model/model_header.hpp&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="kw">namespace</span> some_namespace <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>istream<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>string<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>stringstream<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="kw">using</span> stan<span class="op">::</span>io<span class="op">::</span>dump<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="kw">using</span> stan<span class="op">::</span>math<span class="op">::</span>lgamma<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="kw">using</span> stan<span class="op">::</span>model<span class="op">::</span>prob_grad<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> stan<span class="op">::</span>math<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span>Eigen<span class="op">::</span>Dynamic<span class="op">,</span><span class="dv">1</span><span class="op">&gt;</span> vector_d<span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span>Eigen<span class="op">::</span>Dynamic<span class="op">&gt;</span> row_vector_d<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span>Eigen<span class="op">::</span>Dynamic<span class="op">,</span>Eigen<span class="op">::</span>Dynamic<span class="op">&gt;</span> matrix_d<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="at">static</span> <span class="dt">int</span> <span class="va">current_statement_begin__</span><span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a><span class="co">// various function declarations and / or definitions</span></span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a><span class="pp">#include </span><span class="im">"/full/path/to/fib.hpp"</span></span></code></pre></div>
<p>Thus, the definition of the <code>fib</code> function in the fib.hpp
file need not be enclosed in any particular namespace (which is a random
string by default. The “meta-include” stan/model/model_header.hpp file
reads as</p>
<pre><code><span><span class="co">#ifndef STAN_MODEL_MODEL_HEADER_HPP</span></span>
<span><span class="co">#define STAN_MODEL_MODEL_HEADER_HPP</span></span>
<span></span>
<span><span class="co">#include &lt;stan/math.hpp&gt;</span></span>
<span></span>
<span><span class="co">#include &lt;stan/io/cmd_line.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/io/dump.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/io/reader.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/io/writer.hpp&gt;</span></span>
<span></span>
<span><span class="co">#include &lt;stan/lang/rethrow_located.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/model/model_base.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/model/model_base_crtp.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/model/prob_grad.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/model/indexing.hpp&gt;</span></span>
<span><span class="co">#include &lt;stan/services/util/create_rng.hpp&gt;</span></span>
<span></span>
<span><span class="co">#include &lt;boost/random/additive_combine.hpp&gt;</span></span>
<span><span class="co">#include &lt;boost/random/linear_congruential.hpp&gt;</span></span>
<span></span>
<span><span class="co">#include &lt;cmath&gt;</span></span>
<span><span class="co">#include &lt;cstddef&gt;</span></span>
<span><span class="co">#include &lt;fstream&gt;</span></span>
<span><span class="co">#include &lt;iostream&gt;</span></span>
<span><span class="co">#include &lt;sstream&gt;</span></span>
<span><span class="co">#include &lt;stdexcept&gt;</span></span>
<span><span class="co">#include &lt;utility&gt;</span></span>
<span><span class="co">#include &lt;vector&gt;</span></span>
<span></span>
<span><span class="co">#endif</span></span></code></pre>
<p>so the definition of the <code>fib</code> function in the fib.hpp
file could utilize any function in the Stan Math Library (without having
to prefix function calls with <code>stan::math::</code>), some typedefs
to classes in the Eigen matrix algebra library, plus streams,
exceptions, etc. without having to worry about the corresponding header
files. Nevertheless, an external C++ file <em>may</em> contain
additional include directives that bring in class definitions, for
example.</p>
<p>Now let’s examine the fib.hpp file, which contains the C++ lines</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="dt">int</span> fib<span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span>n<span class="op">,</span> <span class="bu">std::</span>ostream<span class="op">*</span> <span class="va">pstream__</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    stringstream errmsg<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    errmsg <span class="op">&lt;&lt;</span> <span class="st">"n must be positive"</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>domain_error<span class="op">(</span>errmsg<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="cf">return</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> fib<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> fib<span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This C++ function is essentially what the preceding user-defined
function in the Stan language</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode stan"><code class="sourceCode stan"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="dt">int</span> fib(<span class="dt">int</span> n) {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  <span class="cf">if</span> (n &lt;= <span class="dv">0</span>) <span class="kw">reject</span>(<span class="st">"n must be positive"</span>);</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="cf">return</span> n &lt;= <span class="dv">2</span> ? <span class="dv">1</span> : fib(n - <span class="dv">1</span>) + fib(n - <span class="dv">2</span>);</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>}</span></code></pre></div>
<p>parses to. Thus, there is no <em>speed</em> advantage to defining the
<code>fib</code> function in the external fib.hpp file. However, it is
possible to use an external C++ file to handle the gradient of a
function analytically as opposed to using Stan’s autodifferentiation
capabilities, which are slower and more memory intensive but fully
general. In this case, the <code>fib</code> function only deals with
integers so there is nothing to take the derivative of. The primary
advantage of using an external C++ file is flexibility to do things that
cannot be done directly in the Stan language. It is also useful for R
packages like <strong>rstanarm</strong> that may want to define some C++
functions in the package’s src directory and rely on the linker to make
them available in its Stan programs, which are compiled at (or before)
installation time.</p>
<p>In the C++ version, we check if <code>n</code> is non-positive, in
which case we throw an exception. The way the MCMC samplers are
configured, if there is an exception thrown and it is
<code>std::domain_error</code>, it will treat that iteration as a
rejection but as a recoverable error: set that iteration’s log
probability value to negative infinity and move to the next iteration.
If there is a <code>std::invalid_argument</code> thrown, MCMC
terminates. We treat these as non-recoverable, user programming errors.
It is unnecessary to prefix <code>stringstream</code> with
<code>std::</code> because of the <code>using std::stringstream;</code>
line in the <em>generated</em> C++ file. However, there is no
corresponding <code>using std::domain_error;</code> line, so it has to
be qualified appropriately when the exception is thrown.</p>
<p>The only confusing part of the C++ version of the <code>fib</code>
function is that it has an additional argument (with no default value)
named <code>pstream__</code> that is added to the <em>declaration</em>
of the <code>fib</code> function by Stan. Thus, your <em>definition</em>
of the <code>fib</code> function needs to match with this signature.
This additional argument is a pointer to a <code>std::ostream</code> and
is only used if your function prints something to the screen, which is
rare. Thus, when we call the <code>fib</code> function recursively in
the last line, we specify <code>fib(n - 1, 0) + fib(n - 2, 0);</code> so
that the output (if any, and in this case there is none) is directed to
the null pointer.</p>
<p>This vignette has employed a toy example with the Fibonacci function,
which has little apparent use in a Stan program and if it were useful,
would more easily be implemented as a user-defined function in the
<code>functions</code> block as illustrated at the outset. The ability
to use external C++ code only becomes useful with more complicated C++
functions. It goes without saying that this mechanism ordinarily cannot
call functions in C, Fortran, R, or other languages because Stan needs
the derivatives with respect to unknown parameters in order to perform
estimation. These derivatives are handled with custom C++ types that
cannot be processed by functions in other languages that only handle
primitive types such as <code>double</code>, <code>float</code>,
etc.</p>
<p>That said, it is possible to accomplish a great deal in C++,
particularly when utilizing the Stan Math Library. For more details, see
<a href="https://arxiv.org/abs/1509.07164" class="external-link">The Stan Math Library:
Reverse-Mode Automatic Differentiation in C++</a> and its GitHub <a href="https://github.com/stan-dev/math/" class="external-link">repository</a>. The functions
that you <em>declare</em> in the <code>functions</code> block of a Stan
program will typically involve templating and type promotion in their
signatures when parsed to C++ (the only exceptions are functions whose
only arguments are integers, as in the <code>fib</code> function above).
Suppose you wanted to define a function whose arguments are real numbers
(or at least one of the arguments is). For example,</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mc</span> <span class="op">&lt;-</span> </span>
<span><span class="st">'</span></span>
<span><span class="st">functions { real sinc(real x); }</span></span>
<span><span class="st">transformed data { real sinc_pi = sinc(pi()); }</span></span>
<span><span class="st">'</span></span>
<span><span class="fu"><a href="../reference/stan_model.html">stan_model</a></span><span class="op">(</span>model_code <span class="op">=</span> <span class="va">mc</span>, model_name <span class="op">=</span> <span class="st">"external"</span>, allow_undefined <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>           includes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">'\n#include "'</span>, </span>
<span>                             <span class="fu"><a href="https://rdrr.io/r/base/file.path.html" class="external-link">file.path</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/getwd.html" class="external-link">getwd</a></span><span class="op">(</span><span class="op">)</span>, <span class="st">'sinc.hpp'</span><span class="op">)</span>, <span class="st">'"\n'</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in compileCode(f, code, language = language, verbose = verbose):                               ^/Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library/StanHeaders/include/stan/math/rev/fun/trigamma.hpp:23:44: note: in instantiation of function template specialization 'stan::math::trigamma_impl&lt;stan::math::var_value&lt;double&gt;&gt;' requested hereinline var trigamma(const var&amp; u) { return trigamma_impl(u); }                                           ^14 warnings and 3 errors generated.make: *** [filee5ff64f62ea7.o] Error 1</span></span></code></pre>
<pre><code><span><span class="co">## Error in sink(type = "output"): invalid connection</span></span></code></pre>
<p>The sinc.hpp file reads as</p>
<pre><code>double
sinc(const double&amp; x, std::ostream* pstream__) {
  return x != 0.0 ? sin(x) / x : 1.0;
}

var
sinc(const var&amp; x, std::ostream* pstream__) {
  double x_ = x.val();
  double f = x_ != 0.0 ? sin(x_) / x_ : 1.0;
  double dfdx_ = x_ != 0.0 ? (cos(x_) - sin(x_)) / x_ : 0.0;
  return var(new precomp_v_vari(f, x.vi_, dfdx_));
}</code></pre>
<p>The body of the first <code>sinc</code> function is simply its
mathematical definition in the form of a ternary operator, which is
sufficient when the input is a <code>double</code>.</p>
<p>The last lines of sinc.hpp are a specialization for when the input is
an unknown real parameter, which is represented in the Stan Math Library
as a <code>stan::math::var</code>. Since the derivative of the
<code>sinc</code> function is easy to compute analytically, we extract
the underlying double-precision value from the inputted
<code>stan::math::var</code> and use that to calculate the function
value and its first derivative. Then, we return the result of
<code>precomputed_gradients</code>, whose arguments are the function
value (<code>f</code>), the derivative of <code>x</code> with respect to
any other parameters (<code>x.vi_</code>), and the first derivative of
<code>f</code> (<code>dfdx_</code>). The latter two are actually
<code>std::vector</code>s but only have one element each because there
is only one unknown.</p>
<p>An easy way to see what the generated function signature will be is
to call the <code>stanc</code> function in the <strong>rstan</strong>
package with <code>allow_undefined = TRUE</code> and inspect the
resuling C++ code. In this case, I first did</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/readLines.html" class="external-link">readLines</a></span><span class="op">(</span><span class="fu"><a href="../reference/stanc.html">stanc</a></span><span class="op">(</span>model_code <span class="op">=</span> <span class="va">mc</span>, allow_undefined <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">cppcode</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in file(con, "r"): expanded path length 13254 would be too long for</span></span>
<span><span class="co">## #ifndef USE_STANC3</span></span>
<span><span class="co">## #define USE_STANC3</span></span>
<span><span class="co">## #endif</span></span>
<span><span class="co">## // Code generated by stanc v2.26.1-4-gd72b68b7-dirty</span></span>
<span><span class="co">## #include &lt;stan/model/model_header.hpp&gt;</span></span>
<span><span class="co">## namespace modele5ff1af4d640_filee5ff41b042d9_namespace {</span></span>
<span><span class="co">## inline void validate_positive_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                     int val) {</span></span>
<span><span class="co">##   if (val &lt; 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     msg &lt;&lt; "Found dimension size less than one in simplex declaration"</span></span>
<span><span class="co">##         &lt;&lt; "; variable=" &lt;&lt; var_name &lt;&lt; "; dimension size expression=" &lt;&lt; expr</span></span>
<span><span class="co">##         &lt;&lt; "; expression value=" &lt;&lt; val;</span></span>
<span><span class="co">##     std::string msg_str(msg.str());</span></span>
<span><span class="co">##     throw std::invalid_argument(msg_str.c_str());</span></span>
<span><span class="co">##   }</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## inline void validate_unit_vector_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                        int val) {</span></span>
<span><span class="co">##   if (val &lt;= 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     if (val == 1) {</span></span>
<span><span class="co">##       msg &lt;&lt; "Found dimension size one in unit vector declaration."</span></span>
<span><span class="co">##           &lt;&lt; " One-dimensional unit vector is [... truncated]</span></span>
<span></span>
<span><span class="co">## Warning in file(con, "r"): expanded path length 13254 would be too long for</span></span>
<span><span class="co">## #ifndef USE_STANC3</span></span>
<span><span class="co">## #define USE_STANC3</span></span>
<span><span class="co">## #endif</span></span>
<span><span class="co">## // Code generated by stanc v2.26.1-4-gd72b68b7-dirty</span></span>
<span><span class="co">## #include &lt;stan/model/model_header.hpp&gt;</span></span>
<span><span class="co">## namespace modele5ff1af4d640_filee5ff41b042d9_namespace {</span></span>
<span><span class="co">## inline void validate_positive_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                     int val) {</span></span>
<span><span class="co">##   if (val &lt; 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     msg &lt;&lt; "Found dimension size less than one in simplex declaration"</span></span>
<span><span class="co">##         &lt;&lt; "; variable=" &lt;&lt; var_name &lt;&lt; "; dimension size expression=" &lt;&lt; expr</span></span>
<span><span class="co">##         &lt;&lt; "; expression value=" &lt;&lt; val;</span></span>
<span><span class="co">##     std::string msg_str(msg.str());</span></span>
<span><span class="co">##     throw std::invalid_argument(msg_str.c_str());</span></span>
<span><span class="co">##   }</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## inline void validate_unit_vector_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                        int val) {</span></span>
<span><span class="co">##   if (val &lt;= 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     if (val == 1) {</span></span>
<span><span class="co">##       msg &lt;&lt; "Found dimension size one in unit vector declaration."</span></span>
<span><span class="co">##           &lt;&lt; " One-dimensional unit vector is [... truncated]</span></span></code></pre>
<pre><code><span><span class="co">## Warning in file(con, "r"): cannot open file '#ifndef USE_STANC3</span></span>
<span><span class="co">## #define USE_STANC3</span></span>
<span><span class="co">## #endif</span></span>
<span><span class="co">## // Code generated by stanc v2.26.1-4-gd72b68b7-dirty</span></span>
<span><span class="co">## #include &lt;stan/model/model_header.hpp&gt;</span></span>
<span><span class="co">## namespace modele5ff1af4d640_filee5ff41b042d9_namespace {</span></span>
<span><span class="co">## inline void validate_positive_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                     int val) {</span></span>
<span><span class="co">##   if (val &lt; 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     msg &lt;&lt; "Found dimension size less than one in simplex declaration"</span></span>
<span><span class="co">##         &lt;&lt; "; variable=" &lt;&lt; var_name &lt;&lt; "; dimension size expression=" &lt;&lt; expr</span></span>
<span><span class="co">##         &lt;&lt; "; expression value=" &lt;&lt; val;</span></span>
<span><span class="co">##     std::string msg_str(msg.str());</span></span>
<span><span class="co">##     throw std::invalid_argument(msg_str.c_str());</span></span>
<span><span class="co">##   }</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## inline void validate_unit_vector_index(const char* var_name, const char* expr,</span></span>
<span><span class="co">##                                        int val) {</span></span>
<span><span class="co">##   if (val &lt;= 1) {</span></span>
<span><span class="co">##     std::stringstream msg;</span></span>
<span><span class="co">##     if (val == 1) {</span></span>
<span><span class="co">##       msg &lt;&lt; "Found dimension size one in unit vector declaration."</span></span>
<span><span class="co">##           &lt;&lt; " One-dimensional unit vector is discrete"</span></span>
<span><span class="co">##           &lt;&lt; " but t [... truncated]</span></span></code></pre>
<pre><code><span><span class="co">## Error in file(con, "r") : cannot open the connection</span></span></code></pre>
<p>to see what function signatures needed to be written for
sinc.hpp.</p>
<p>Once you go to the trouble of writing a numerically stable C++
function, we would welcome a pull request on GitHub to include your C++
function in the Stan Math Library for everyone to benefit from, provided
that it can be licensed under the 3-clause BSD license and its use is
not overly-specific to your particular Stan program.</p>
<p>The Stan Math Library is compliant with the C++14 standard but not
all compilers fully support the C++14 standard. In particular, the
compiler that comes with RTools does not support all C++14 features. But
you can use many C++14 features, such as the <code>auto</code>
keyword.</p>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jiqiang Guo, Jonah Gabry, Ben Goodrich, Andrew Johnson, Sebastian Weber.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
